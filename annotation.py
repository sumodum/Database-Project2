# "annotations.py" is to format/generate the query plans for the inputted SQL queries

class Annotator:

    def __init__(self):
        self.iCount = 0
        self.stepCount = 0

    # wrapper function to pre-process the QEP and return the final string only
    def wrapper(self, qep):
        final = self.annotate(qep[0][0][0]['Plan'], True)[1]
        final = final[:-2]
        final += " to get the final result."
        return final 

    def annotate(self, query, first = False):
        # To store previous tables that are not included in the QEP
        joinTables = []

        # Combine the resultant string with output from the current iteration
        result = ""

        if "Plans" in query:
            for plan in query["Plans"]:
                temp = self.annotate(plan)
                joinTables.append(temp[0])
                result += temp[1]

        self.stepCount += 1
        result += "Step {}: ".format(self.stepCount)

        if query["Node Type"] == 'Seq Scan':
            table = query["Relation Name"]
            name = query["Alias"]
            text = "Perform sequential scan on table {} as {}".format(table, name)
            if "Filter" in query:
                text += " with filter {}".format(query["Filter"])
            text += ". \n"
            extra_comment = "It is a method that scans the file(s) of the main table fork entirely.\n It iterates over each tuple and checks whether to include it.\n It is the most cost-effective way of scanning a whole table or a significant portion of it, when the selectivity of WHERE clauses is low \n"
            return table, result + text + extra_comment


        elif query["Node Type"] == 'Index Scan':
            table = query["Relation Name"]
            name = query["Alias"]
            text = "Perform index scan on table {} as {} using index on {}".format(table, name, query["Index Name"])
            if "Index Cond" in query:
                text += " where {}".format(query["Index Cond"])
            if "Filter" in query:
                text += " with filter {}".format(query["Filter"])
            text += ". \n"
            extra_comment = "It picks an index to find the tuples that the query needs.\n If all the data the query requires is stored in an index, return of the data can be accomplished in fewer page reads than if the scan was done on the table.\n"
            return table, result + text + extra_comment


        elif query["Node Type"] == 'Index-Only Scan':
            table = query["Relation Name"]
            name = query["Alias"]
            text = "Perform index scan on table {} as {} using index on {}".format(table, name, query["Index Name"])
            if "Index Cond" in query:
                text += " where {}".format(query["Index Cond"])
            if "Filter" in query:
                text += " with filter {}".format(query["Filter"])
            text += ". \n"
            extra_comment = "It performs a B-tree traversal and walks through the leaf nodes to find all matching entries.\n The index type must support index-only scans and the query must reference only columns stored in the index.\n There is no table access required because the index has all columns to satisfy the query.\n"
            return table, result + text + extra_comment

        elif query["Node Type"] == 'Bitmap Index Scan':
            table = query["Relation Name"]
            name = query["Alias"]
            text = "Perform bitmap index scan on table {} as {} using index on {}".format(table, name, query["Index Name"])
            if "Index Cond" in query:
                text += " where {}".format(query["Index Cond"])
            if "Filter" in query:
                text += " with filter {}".format(query["Filter"])
            text += ". \n"
            extra_comment = "It scans an index to determine exactly what data it needs to fetch and it takes advantage of data being easier to read in bulk.\n"
            return table, result + text + extra_comment


        elif query["Node Type"] == 'Bitmap Heap Scan':
            table = query["Relation Name"]
            name = query["Alias"]
            text = "Perform bitmap heap scan on table {} as {} using index on {}".format(table, name, query["Bitmap"])
            if "Index Cond" in query:
                text += " where {}".format(query["Index Cond"])
            if "Filter" in query:
                text += " with filter {}".format(query["Filter"])
            text += ". \n"
            extra_comment = "It takes a row location bitmap generated by a Bitmap Index Scan and looks up the relevant data.\n Each chunk of a bitmap can either be exact, pointing directly to rows, or lossy, pointing to a page containing at least one row matching the predicate.\n"
            return table, result + text + extra_comment
        

        elif query["Node Type"] == 'BitmapAnd':
            text = "Perform bitmapAnd on bitmap of table {}. \n".format(joinTables[0])
            extra_comment = "It generates a bitmap of the intersection of two physical row location bitmaps.\n Due to internal implementation limitations, BitmapAnd nodes do not track the number of rows they produce.\n The row count will always be listed as \"Unknown\" and they will not be flagged as mis-estimates.\n"
            return joinTables[0], result + text + extra_comment


        elif query["Node Type"] == 'BitmapAOr':
            text = "Perform bitmapOr on bitmap of table {}. \n".format(joinTables[0])
            extra_comment = "It generates a bitmap of the union of two physical row location bitmaps.\n Due to internal implementation limitations, BitmapOr nodes do not track the number of rows they produce.\n The row count will always be listed as \"Unknown\" and they will not be flagged as mis-estimates.\n"
            return joinTables[0], result + text + extra_comment


        elif query["Node Type"] == 'CTE Scan':
            table = query["CTE Name"]
            name = query["Alias"]
            text = "Perform CTE scan on table {} as {}".format(table, name)
            if "Filter" in query:
                text += " with filter {}".format(query["Filter"])
            text += ". \n"
            extra_comment = "It is a sequential scan of the materialized results of a CTE term, which is usually generated by WITH statements.\n It makes the operations in the subquery to be evaluated and the intermediate results stored to be used later in the query.\n"
            return table, result + text + extra_comment


        elif query["Node Type"] == 'Foreign Scan':
            table = query["Relation Name"]
            name = query["Alias"]
            text = "Perform foreign scan on table {} from schema {} as {}. \n".format(table, query["Schema"], name)
            extra_comment = "It reads data drom a remote data source and presents the data as relational tables.\n It is often possible for PostgreSQL to delegate operations to a remote database.\n"
            return table, result + text + extra_comment

        
        elif query["Node Type"] == 'Function Scan':
            table = query["Schema"]
            name = query["alias"]
            text = "Perform function {} on schema {} and return the results as {}".format(query["Function Name"], table, name)
            if "Filter" in query:
                text += " with filter {}".format(query["Filter"])
            text += ". \n"
            extra_comment = "It takes the results of a set-returning function and returns them as if they were rows, read from a table.\n PostgreSQL considers functions to be volatile, unless specified to be immutable or stable, which can affect query planning.\n"
            return table, result + text + extra_comment

        
        elif query["Node Type"] == 'Subquery Scan':
            text = "The subquery results from the previous operation is read"
            if "Filter" in query:
                text += " with filter {}".format(query["Filter"])
            text += ". \n"
            extra_comment = "It reads the output of a sub-query in the range table.\n An extra plan node above the sub-query's plan is required to perform expression evaluations.\n"
            return joinTables[0], result + text + extra_comment


        elif query["Node Type"] == 'WorkTable Scan':
            text = "The intermediate stages in an operation is read"
            if "Filter" in query:
                text += " with filter {}".format(query["Filter"])
            text += ". \n"
            extra_comment = "It is usually accompanied by a recursive operation that is declared using WITH RECURSIVE.\n"
            return joinTables[0], result + text + extra_comment

        
        elif query["Node Type"] == 'TID Scan':
            table = query["Relation"]
            name = query["Alias"]
            text = "Perform a Tuple ID scan on table {} as {}. \n".format(table ,name)
            extra_comment = "It gets selected only if there is TID (Tuple Identifier) in the query predicate.\n It is fast, but unreliable in long term becuase TID would change if the row is updated or moved.\n"
            return table, result + text + extra_comment

        
        elif query["Node Type"] == 'Custom Scan':
            table = query["Relation Name"]
            name = query["Alias"]
            text = "Perform custom scan on table {} from schema {} as {}. \n".format(table, query["Schema"], name)
            extra_comment = "It is a new custom scan type that extends the ways in which PostgreSQL can read data.\n This allows PostgreSQL to take advantage of a new form of caching or a new hardware development.\n"
            return table, result + text + extra_comment


        elif query["Node Type"] == 'Nested Loop':
            self.iCount += 1
            text = "Perform a nested loop join on tables {} and {}".format(joinTables[0], joinTables[1])
            if "Join Filter" in query:
                text += " under the condition {}".format(joinTables[0], joinTables[1], query["Join Filter"])
            if "Filter" in query:
                text += " with filter {}".format(query["Filter"])
            if not first:
                text += " to get intermediate table T{}. \n".format(self.iCount)
            else: text += ". \n"
            extra_comment = "It comprises 2 loops - an inner and an outer loops.\n The outer loop searches through all the rows of the outer table and for every such row, the inner loop searches for matching rows in the second inner table.\n A nested loop join is the most efficient way to compute a Cartesian product, regardless of the number of rows in both tables.\n"
            return "T" + str(self.iCount), result + text + extra_comment

        
        elif query["Node Type"] == 'Hash Join':
            self.iCount += 1
            text = "Perform a hash join on tables {} and {}".format(joinTables[0], joinTables[1])
            if "Hash Cond" in query:
                text += " under the condition {}".format(query["Hash Cond"])
            if "Filter" in query:
                text += " with filter {}".format(query["Filter"])
            if not first:
                text += " to get intermediate table T{}. \n".format(self.iCount)
            else: text += ". \n"
            extra_comment = "It loads the candidate records from a table of the join into a hash table which is then probed for each record from the other table.\n It is preferred if the join condition uses an equality (=) operator and both sides of the join are large and the hash fits into the memory.\n"
            return "T" + str(self.iCount), result + text + extra_comment


        elif query["Node Type"] == 'Merge Join':
            self.iCount += 1
            text = "Perform a merge join on tables {} and {}".format(joinTables[0], joinTables[1])
            if "Merge Cond" in query:
                text += " under the condition {}".format(query["Merge Cond"])
            if "Filter" in query:
                text += " with filter {}".format(query["Filter"])
            #else: text += ". \n"
            if not first:
                text += " to get intermediate table T{}. \n".format(self.iCount)
            text += ". \n"
            extra_comment = "It combines 2 sorted lists like a zipper.\n It is preferred if the join condition uses an equality (=) operator and both sides of the join are large and the tables of the join are already sorted.\n"
            return "T" + str(self.iCount), result + text + extra_comment

        
        elif query["Node Type"] == 'Aggregate':
            self.iCount += 1
            text = "Perform aggregate on table {}".format(joinTables[0])
            if not first:
                text += " to get intermediate table T{}. \n".format(self.iCount)
            else: text += ". \n"
            extra_comment = "It produces a single result for an entire table.\n It operates on sets of rows and returns results based on the groups of the rows.\n The GROUP BY clause of the select statement is used to divide rows into smaller groups.\n"
            return "T" + str(self.iCount), result + text + extra_comment

        
        elif query["Node Type"] == 'Append':
            self.iCount += 1
            text = "Append the results from table {} to table {}".format(joinTables[0], joinTables[1]) 
            if not first:
                text += " to get intermediate table T{}. \n".format(self.iCount)
            else: text += ". \n"
            extra_comment = "It adds the value at the end of an array.\n"
            return "T" + str(self.iCount), result + text + extra_comment

   
        elif query["Node Type"] == 'Gather':
            self.iCount += 1
            text = ("Perform gather on table {}".format(joinTables[0]))
            if not first:
                text += " to get intermediate table T{}. \n".format(self.iCount)
            else: text += ". \n"
            extra_comment = "It allows processes below it in the query execution plan to run in parallel.\n Tuples are collected from child nodes in no particular order.\n"
            return "T" + str(self.iCount), result + text + extra_comment

        
        elif query["Node Type"] == 'Gather Merge':
            text = "The results of the previous operation are gathered and merged. \n"
            extra_comment = "It allows processes below it in the query execution plan to run in parallel.\n Sorted tuples are produced by child nodes and the merge preserves order of the sort.\n"
            return joinTables[0], result + text + extra_comment

        
        elif query["Node Type"] == 'GroupAggregate':
            self.iCount += 1
            text = "Perform a group aggregate on table {}".format(joinTables[0])
            if not first:
                text += " to get intermediate table T{}. \n".format(self.iCount)
            else: text += ". \n"
            extra_comment = "It aggregates already sorted rows according to the GROUP BY clause.\n"
            return "T" + str(self.iCount), result + text + extra_comment

        
        elif query["Node Type"] == 'Hash':
            text = "Perform hashing on table {}. \n".format(joinTables[0])
            extra_comment = "It hashes query rows for the parent operation.\n"
            return joinTables[0], result + text + extra_comment


        elif query["Node Type"] == 'HashAggregate':
            self.iCount += 1
            text = "Perform a hash aggregate on table {}".format(joinTables[0])
            if not first:
                text += " to get intermediate table T{}. \n".format(self.iCount)
            else: text += ". \n"
            extra_comment = "It aggregates rows for the GROUP BY clause.\n The difference between HashAggregate and GroupAggregate is that the latter can work on unsorted data.\n"
            return "T" + str(self.iCount), result + text + extra_comment


        elif query["Node Type"] == 'HashSetOp':
            text = "Perform a hash set operation on table {}. \n".format(joinTables[0])
            extra_comment = "It is a strategy for set operations like INTERSECT or EXCEPT that uses Append to avoid needing pre-sorted input.\n "
            return joinTables[0], result + text + extra_comment


        elif query["Node Type"] == 'SetOp':
            self.iCount += 1
            text = "A set operation is performed on table {}".format(joinTables[0])
            if not first:
                text += " to get intermediate table T{}. \n".format(self.iCount)
            else: text += ". \n"
            extra_comment = "It performs a set operation like INTERSECT or EXCEPT.\n The UNION operation is not handled by SetOp, but by Append or MergeAppend.\n"
            return "T" + str(self.iCount), result + text + extra_comment


        elif query["Node Type"] == 'Incremental Sort':
            text = "An incremetal sort is performed on table {} with sort key {}. \n".format(joinTables[0], query["Sort Key"])
            extra_comment = "When a query needs to be sorted on more than one attribute and an index is on one of them, incremental sort uses this index and only sorts based on other attributes for entries having the same value for the attribute with an index.\n This is efficient in terms of both time and memory.\n"
            return joinTables[0], result + text + extra_comment


        elif query["Node Type"] == 'Sort':
            text = "Perform a sort on table {} with sort key {}. \n".format(joinTables[0], query["Sort Key"])
            extra_comment = "It sorts rows into an order, usually as a result of an ORDER BY clause.\n Sorting many rows can be expensive in terms of both time and memory.\n The user\'s setting of memory determines how much memory is available to PostgreSQL per sort.\n If a sort requires more than how much memory permits, it needs to use the disk.\n"
            return joinTables[0], result + text + extra_comment


        elif query["Node Type"] == 'Limit':
            text = "The specified number of rows is selected from table {}. \n".format(joinTables[0])
            extra_comment = "It limits the number of rows selected according to the number entered by the user.\n"
            return joinTables[0], result + text + extra_comment


        elif query["Node Type"] == 'LockRows':
            text = "Some rows from table {} are locked. \n".format(joinTables[0])
            extra_comment = "It locks the rows in question to block other queries from writing to them, butreads are allowed.\n"
            return joinTables[0], result + text + extra_comment


        elif query["Node Type"] == 'Group':
                    text = "The grouping for the users of table {}. \n".format(joinTables[0])
                    extra_comment = "It is to ease management of privilege.\n Privileges can be granted to or revoked from a group as a whole.\n"
                    return "", result + text + extra_comment


        elif query["Node Type"] == 'Materialize':
            text = "Materialize table {}. \n".format(joinTables[0])
            extra_comment = "It means that the intermediate results of the previous operation (i.e. the one below it in the tree) are small enough to be stored in the memory and they are stored so that the next operation can access them.\n"
            return joinTables[0], result + text + extra_comment


        elif query["Node Type"] == 'MergeAppend':
            self.iCount += 1
            text = "Results from table {} are appended to table {}".format(joinTables[0], joinTables[1])
            if not first:
                text += " to get intermediate table T{}. \n".format(self.iCount)
            else: text += ". \n"
            extra_comment = "It combines the sorted results of the child operations in such a way that preserves the order in which they are sorted.\n"
            return "T" + str(self.iCount), result + text + extra_comment


        elif query["Node Type"] == 'ModifyTable':
            table = query["Relation Name"]
            text = "Table {} is modified. \n ".format(table)
            extra_comment = "It is used to write data to a table, update data or delete data.\n"
            return table, result + text + extra_comment


        elif query["Node Type"] == 'RecursiveUnion':
            text = "Perform a recursive union on table {}. \n".format(joinTables[0])
            extra_comment = "A working table is used to process recursive CTEs.\n Duplicate rows are removed and the union processes is not really recursive, but rather iterative.\n"
            return joinTables[0], result + text + extra_comment


        elif query["Node Type"] == 'Unique':
            table = query["Subplan Name"] if "Subplan Name" in query else joinTables[0]
            text = "Duplicates are removed from table {}. \n".format(table)
            extra_comment = "It ensures that no duplicates exist in a table or index.\n"
            return table, result + text + extra_comment


        else:
            text = "Perform {}. \n".format(query["Node Type"])
            return joinTables[0], result + text